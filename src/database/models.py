"""
Database models for the trading bot.
Uses SQLAlchemy ORM for database abstraction (SQLite in Phase 1, PostgreSQL-ready).
"""

from datetime import datetime
from typing import Optional
from sqlalchemy import (
    Column, Integer, String, Float, DateTime, Boolean,
    ForeignKey, JSON, Enum as SQLEnum, Text
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
import enum


Base = declarative_base()


class PositionStatus(enum.Enum):
    """Position status enumeration"""
    OPEN = "open"
    CLOSED = "closed"
    PARTIAL = "partial"


class SignalType(enum.Enum):
    """Trading signal type"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class TradeSide(enum.Enum):
    """Trade side enumeration"""
    BUY = "buy"
    SELL = "sell"


class Position(Base):
    """
    Tracks trading positions (both open and closed).
    Links to the strategy that opened it and maintains complete entry/exit data.
    """
    __tablename__ = "positions"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    platform = Column(String(20), nullable=False, default="alpaca")
    quantity = Column(Float, nullable=False)
    entry_price = Column(Float, nullable=False)
    entry_date = Column(DateTime, nullable=False, default=datetime.utcnow)
    exit_price = Column(Float, nullable=True)
    exit_date = Column(DateTime, nullable=True)

    # Strategy information
    strategy = Column(String(50), nullable=False, index=True)
    confidence_score = Column(Float, nullable=True)

    # Risk management
    stop_loss = Column(Float, nullable=True)
    take_profit = Column(Float, nullable=True)

    # Status
    status = Column(SQLEnum(PositionStatus), nullable=False, default=PositionStatus.OPEN, index=True)

    # Alpaca integration
    alpaca_order_id = Column(String(100), nullable=True)
    alpaca_position_id = Column(String(100), nullable=True)
    alpaca_stop_order_id = Column(String(100), nullable=True)  # Stop-loss order on Alpaca
    alpaca_tp_order_id = Column(String(100), nullable=True)    # Take-profit order on Alpaca

    # Metadata
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    trades = relationship("Trade", back_populates="position", cascade="all, delete-orphan")

    def __repr__(self) -> str:
        return f"<Position(id={self.id}, symbol={self.symbol}, status={self.status.value}, qty={self.quantity})>"

    @property
    def current_value(self) -> float:
        """Calculate current position value"""
        if self.status == PositionStatus.CLOSED and self.exit_price:
            return self.quantity * self.exit_price
        return self.quantity * self.entry_price

    @property
    def pnl(self) -> Optional[float]:
        """Calculate profit/loss"""
        if self.status == PositionStatus.CLOSED and self.exit_price:
            return (self.exit_price - self.entry_price) * self.quantity
        return None

    @property
    def pnl_pct(self) -> Optional[float]:
        """Calculate profit/loss percentage"""
        if self.status == PositionStatus.CLOSED and self.exit_price:
            return ((self.exit_price - self.entry_price) / self.entry_price) * 100
        return None


class Trade(Base):
    """
    Individual trade executions (buy/sell orders).
    Linked to positions for complete audit trail.
    """
    __tablename__ = "trades"

    id = Column(Integer, primary_key=True, autoincrement=True)
    position_id = Column(Integer, ForeignKey("positions.id"), nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    side = Column(SQLEnum(TradeSide), nullable=False)
    quantity = Column(Float, nullable=False)
    price = Column(Float, nullable=False)
    filled_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Costs
    commission = Column(Float, default=0.0)
    fees = Column(Float, default=0.0)

    # Alpaca integration
    alpaca_order_id = Column(String(100), nullable=True, unique=True)
    alpaca_client_order_id = Column(String(100), nullable=True)

    # Metadata
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    position = relationship("Position", back_populates="trades")

    def __repr__(self) -> str:
        return f"<Trade(id={self.id}, symbol={self.symbol}, side={self.side.value}, qty={self.quantity}, price={self.price})>"

    @property
    def total_value(self) -> float:
        """Calculate total trade value"""
        return self.quantity * self.price

    @property
    def total_cost(self) -> float:
        """Calculate total cost including fees"""
        return self.total_value + self.commission + self.fees


class Signal(Base):
    """
    Trading signals generated by strategies.
    Maintains historical record of all signals and their execution status.
    """
    __tablename__ = "signals"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    strategy = Column(String(50), nullable=False, index=True)
    signal_type = Column(SQLEnum(SignalType), nullable=False)
    confidence = Column(Float, nullable=False)

    # Data snapshot for reproducibility
    data_snapshot = Column(JSON, nullable=True)

    # Execution tracking
    executed = Column(Boolean, default=False, index=True)
    execution_time = Column(DateTime, nullable=True)
    execution_notes = Column(Text, nullable=True)

    # Linked position if executed
    position_id = Column(Integer, ForeignKey("positions.id"), nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<Signal(id={self.id}, symbol={self.symbol}, type={self.signal_type.value}, confidence={self.confidence:.2f}, executed={self.executed})>"


class PortfolioSnapshot(Base):
    """
    Daily portfolio snapshots for performance tracking.
    Captures portfolio state at specific points in time.
    """
    __tablename__ = "portfolio_snapshots"

    id = Column(Integer, primary_key=True, autoincrement=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, unique=True, index=True)

    # Portfolio values
    total_value = Column(Float, nullable=False)
    cash = Column(Float, nullable=False)
    positions_value = Column(Float, nullable=False)

    # Returns
    daily_return_pct = Column(Float, nullable=True)
    total_return_pct = Column(Float, nullable=True)

    # Position tracking
    position_count = Column(Integer, default=0)
    open_positions_count = Column(Integer, default=0)

    # Risk metrics
    portfolio_exposure_pct = Column(Float, nullable=True)

    # Snapshot data
    positions_snapshot = Column(JSON, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<PortfolioSnapshot(timestamp={self.timestamp}, value={self.total_value:.2f}, positions={self.position_count})>"


class BotLog(Base):
    """
    General bot activity logs for tracking system events.
    Complements structured file logging with database storage.
    """
    __tablename__ = "bot_logs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    level = Column(String(20), nullable=False, index=True)
    event_type = Column(String(50), nullable=False, index=True)
    message = Column(Text, nullable=False)

    # Context data
    context = Column(JSON, nullable=True)

    # Error tracking
    error_type = Column(String(100), nullable=True)
    stack_trace = Column(Text, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<BotLog(id={self.id}, level={self.level}, event={self.event_type})>"


class SentimentSource(enum.Enum):
    """Source of sentiment data"""
    REDDIT_WSB = "reddit_wsb"
    REDDIT_STOCKS = "reddit_stocks"
    REDDIT_INVESTING = "reddit_investing"
    REDDIT_OPTIONS = "reddit_options"
    TWITTER = "twitter"
    NEWS = "news"


class SentimentData(Base):
    """
    Stores sentiment data from various sources (Reddit, Twitter, News).
    Used for sentiment-based trading signals and stock discovery.
    """
    __tablename__ = "sentiment_data"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    source = Column(SQLEnum(SentimentSource), nullable=False, index=True)

    # Sentiment metrics
    sentiment_score = Column(Float, nullable=False)  # -1 (bearish) to +1 (bullish)
    mention_count = Column(Integer, default=0)
    total_score = Column(Integer, default=0)  # Total upvotes/likes
    avg_upvote_ratio = Column(Float, nullable=True)

    # Breakdown
    positive_pct = Column(Float, nullable=True)
    negative_pct = Column(Float, nullable=True)
    neutral_pct = Column(Float, nullable=True)

    # Raw data for analysis
    sample_titles = Column(JSON, nullable=True)  # Sample post titles
    post_ids = Column(JSON, nullable=True)  # Reference to source posts

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<SentimentData(symbol={self.symbol}, source={self.source.value}, score={self.sentiment_score:.2f}, mentions={self.mention_count})>"

    @property
    def is_bullish(self) -> bool:
        """Check if sentiment is bullish (> 0.05)"""
        return self.sentiment_score > 0.05

    @property
    def is_bearish(self) -> bool:
        """Check if sentiment is bearish (< -0.05)"""
        return self.sentiment_score < -0.05

    @property
    def sentiment_label(self) -> str:
        """Get human-readable sentiment label"""
        if self.sentiment_score >= 0.5:
            return "very_bullish"
        elif self.sentiment_score >= 0.2:
            return "bullish"
        elif self.sentiment_score >= 0.05:
            return "slightly_bullish"
        elif self.sentiment_score <= -0.5:
            return "very_bearish"
        elif self.sentiment_score <= -0.2:
            return "bearish"
        elif self.sentiment_score <= -0.05:
            return "slightly_bearish"
        else:
            return "neutral"


class WsbTrending(Base):
    """
    Tracks trending stocks on r/wallstreetbets.
    Refreshed periodically to capture momentum.
    """
    __tablename__ = "wsb_trending"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Trending metrics
    mentions = Column(Integer, nullable=False)
    rank = Column(Integer, nullable=True)  # Rank by mentions
    sentiment_score = Column(Float, nullable=True)

    # Additional context
    total_score = Column(Integer, default=0)
    sample_titles = Column(JSON, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<WsbTrending(symbol={self.symbol}, mentions={self.mentions}, rank={self.rank})>"
