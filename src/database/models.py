"""
Database models for the trading bot.
Uses SQLAlchemy ORM for database abstraction (SQLite in Phase 1, PostgreSQL-ready).
"""

from datetime import datetime
from typing import Optional
from sqlalchemy import (
    Column, Integer, String, Float, DateTime, Boolean,
    ForeignKey, JSON, Enum as SQLEnum, Text
)
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
import enum


Base = declarative_base()


class PositionStatus(enum.Enum):
    """Position status enumeration"""
    OPEN = "open"
    CLOSED = "closed"
    PARTIAL = "partial"


class SignalType(enum.Enum):
    """Trading signal type"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class TradeSide(enum.Enum):
    """Trade side enumeration"""
    BUY = "buy"
    SELL = "sell"


class Position(Base):
    """
    Tracks trading positions (both open and closed).
    Links to the strategy that opened it and maintains complete entry/exit data.
    """
    __tablename__ = "positions"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    platform = Column(String(20), nullable=False, default="alpaca")
    quantity = Column(Float, nullable=False)
    entry_price = Column(Float, nullable=False)
    entry_date = Column(DateTime, nullable=False, default=datetime.utcnow)
    exit_price = Column(Float, nullable=True)
    exit_date = Column(DateTime, nullable=True)

    # Strategy information
    strategy = Column(String(50), nullable=False, index=True)
    confidence_score = Column(Float, nullable=True)

    # Risk management
    stop_loss = Column(Float, nullable=True)
    take_profit = Column(Float, nullable=True)

    # Status
    status = Column(SQLEnum(PositionStatus), nullable=False, default=PositionStatus.OPEN, index=True)

    # Alpaca integration
    alpaca_order_id = Column(String(100), nullable=True)
    alpaca_position_id = Column(String(100), nullable=True)
    alpaca_stop_order_id = Column(String(100), nullable=True)  # Stop-loss order on Alpaca
    alpaca_tp_order_id = Column(String(100), nullable=True)    # Take-profit order on Alpaca

    # Metadata
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    trades = relationship("Trade", back_populates="position", cascade="all, delete-orphan")

    def __repr__(self) -> str:
        return f"<Position(id={self.id}, symbol={self.symbol}, status={self.status.value}, qty={self.quantity})>"

    @property
    def current_value(self) -> float:
        """Calculate current position value"""
        if self.status == PositionStatus.CLOSED and self.exit_price:
            return self.quantity * self.exit_price
        return self.quantity * self.entry_price

    @property
    def pnl(self) -> Optional[float]:
        """Calculate profit/loss"""
        if self.status == PositionStatus.CLOSED and self.exit_price:
            return (self.exit_price - self.entry_price) * self.quantity
        return None

    @property
    def pnl_pct(self) -> Optional[float]:
        """Calculate profit/loss percentage"""
        if self.status == PositionStatus.CLOSED and self.exit_price:
            return ((self.exit_price - self.entry_price) / self.entry_price) * 100
        return None


class Trade(Base):
    """
    Individual trade executions (buy/sell orders).
    Linked to positions for complete audit trail.
    """
    __tablename__ = "trades"

    id = Column(Integer, primary_key=True, autoincrement=True)
    position_id = Column(Integer, ForeignKey("positions.id"), nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    side = Column(SQLEnum(TradeSide), nullable=False)
    quantity = Column(Float, nullable=False)
    price = Column(Float, nullable=False)
    filled_at = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Costs
    commission = Column(Float, default=0.0)
    fees = Column(Float, default=0.0)

    # Alpaca integration
    alpaca_order_id = Column(String(100), nullable=True, unique=True)
    alpaca_client_order_id = Column(String(100), nullable=True)

    # Metadata
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationships
    position = relationship("Position", back_populates="trades")

    def __repr__(self) -> str:
        return f"<Trade(id={self.id}, symbol={self.symbol}, side={self.side.value}, qty={self.quantity}, price={self.price})>"

    @property
    def total_value(self) -> float:
        """Calculate total trade value"""
        return self.quantity * self.price

    @property
    def total_cost(self) -> float:
        """Calculate total cost including fees"""
        return self.total_value + self.commission + self.fees


class Signal(Base):
    """
    Trading signals generated by strategies.
    Maintains historical record of all signals and their execution status.
    """
    __tablename__ = "signals"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    strategy = Column(String(50), nullable=False, index=True)
    signal_type = Column(SQLEnum(SignalType), nullable=False)
    confidence = Column(Float, nullable=False)

    # Data snapshot for reproducibility
    data_snapshot = Column(JSON, nullable=True)

    # Execution tracking
    executed = Column(Boolean, default=False, index=True)
    execution_time = Column(DateTime, nullable=True)
    execution_notes = Column(Text, nullable=True)

    # Linked position if executed
    position_id = Column(Integer, ForeignKey("positions.id"), nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<Signal(id={self.id}, symbol={self.symbol}, type={self.signal_type.value}, confidence={self.confidence:.2f}, executed={self.executed})>"


class PortfolioSnapshot(Base):
    """
    Daily portfolio snapshots for performance tracking.
    Captures portfolio state at specific points in time.
    """
    __tablename__ = "portfolio_snapshots"

    id = Column(Integer, primary_key=True, autoincrement=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, unique=True, index=True)

    # Portfolio values
    total_value = Column(Float, nullable=False)
    cash = Column(Float, nullable=False)
    positions_value = Column(Float, nullable=False)

    # Returns
    daily_return_pct = Column(Float, nullable=True)
    total_return_pct = Column(Float, nullable=True)

    # Position tracking
    position_count = Column(Integer, default=0)
    open_positions_count = Column(Integer, default=0)

    # Risk metrics
    portfolio_exposure_pct = Column(Float, nullable=True)

    # Snapshot data
    positions_snapshot = Column(JSON, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<PortfolioSnapshot(timestamp={self.timestamp}, value={self.total_value:.2f}, positions={self.position_count})>"


class BotLog(Base):
    """
    General bot activity logs for tracking system events.
    Complements structured file logging with database storage.
    """
    __tablename__ = "bot_logs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    level = Column(String(20), nullable=False, index=True)
    event_type = Column(String(50), nullable=False, index=True)
    message = Column(Text, nullable=False)

    # Context data
    context = Column(JSON, nullable=True)

    # Error tracking
    error_type = Column(String(100), nullable=True)
    stack_trace = Column(Text, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<BotLog(id={self.id}, level={self.level}, event={self.event_type})>"


class SentimentSource(enum.Enum):
    """Source of sentiment data"""
    REDDIT_WSB = "reddit_wsb"
    REDDIT_STOCKS = "reddit_stocks"
    REDDIT_INVESTING = "reddit_investing"
    REDDIT_OPTIONS = "reddit_options"
    TWITTER = "twitter"
    NEWS = "news"


class SentimentData(Base):
    """
    Stores sentiment data from various sources (Reddit, Twitter, News).
    Used for sentiment-based trading signals and stock discovery.
    """
    __tablename__ = "sentiment_data"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    source = Column(SQLEnum(SentimentSource), nullable=False, index=True)

    # Sentiment metrics
    sentiment_score = Column(Float, nullable=False)  # -1 (bearish) to +1 (bullish)
    mention_count = Column(Integer, default=0)
    total_score = Column(Integer, default=0)  # Total upvotes/likes
    avg_upvote_ratio = Column(Float, nullable=True)

    # Breakdown
    positive_pct = Column(Float, nullable=True)
    negative_pct = Column(Float, nullable=True)
    neutral_pct = Column(Float, nullable=True)

    # Raw data for analysis
    sample_titles = Column(JSON, nullable=True)  # Sample post titles
    post_ids = Column(JSON, nullable=True)  # Reference to source posts

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<SentimentData(symbol={self.symbol}, source={self.source.value}, score={self.sentiment_score:.2f}, mentions={self.mention_count})>"

    @property
    def is_bullish(self) -> bool:
        """Check if sentiment is bullish (> 0.05)"""
        return self.sentiment_score > 0.05

    @property
    def is_bearish(self) -> bool:
        """Check if sentiment is bearish (< -0.05)"""
        return self.sentiment_score < -0.05

    @property
    def sentiment_label(self) -> str:
        """Get human-readable sentiment label"""
        if self.sentiment_score >= 0.5:
            return "very_bullish"
        elif self.sentiment_score >= 0.2:
            return "bullish"
        elif self.sentiment_score >= 0.05:
            return "slightly_bullish"
        elif self.sentiment_score <= -0.5:
            return "very_bearish"
        elif self.sentiment_score <= -0.2:
            return "bearish"
        elif self.sentiment_score <= -0.05:
            return "slightly_bearish"
        else:
            return "neutral"


class WsbTrending(Base):
    """
    Tracks trending stocks on r/wallstreetbets.
    Refreshed periodically to capture momentum.
    """
    __tablename__ = "wsb_trending"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Trending metrics
    mentions = Column(Integer, nullable=False)
    rank = Column(Integer, nullable=True)  # Rank by mentions
    sentiment_score = Column(Float, nullable=True)

    # Additional context
    total_score = Column(Integer, default=0)
    sample_titles = Column(JSON, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<WsbTrending(symbol={self.symbol}, mentions={self.mentions}, rank={self.rank})>"


# ============================================================
# NEW MODELS FOR ENHANCED TRACKING (Dashboard v2)
# ============================================================


class RejectionReason(enum.Enum):
    """Reasons for signal/order rejection"""
    INSUFFICIENT_CASH = "insufficient_cash"
    EXPOSURE_LIMIT = "exposure_limit"
    POSITION_SIZE_LIMIT = "position_size_limit"
    DAILY_LOSS_LIMIT = "daily_loss_limit"
    DUPLICATE_POSITION = "duplicate_position"
    MARKET_CLOSED = "market_closed"
    LOW_CONFIDENCE = "low_confidence"
    RISK_CHECK_FAILED = "risk_check_failed"
    API_ERROR = "api_error"
    UNKNOWN = "unknown"


class OrderRejection(Base):
    """
    Tracks why signals or orders weren't executed.
    Provides insight into missed opportunities and risk management decisions.
    """
    __tablename__ = "order_rejections"

    id = Column(Integer, primary_key=True, autoincrement=True)
    signal_id = Column(Integer, ForeignKey("signals.id"), nullable=True, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    strategy = Column(String(50), nullable=False, index=True)

    # Rejection details
    rejection_reason = Column(SQLEnum(RejectionReason), nullable=False, index=True)
    rejection_details = Column(Text, nullable=True)

    # Order details at rejection time
    requested_side = Column(SQLEnum(TradeSide), nullable=True)
    requested_quantity = Column(Float, nullable=True)
    requested_price = Column(Float, nullable=True)
    signal_confidence = Column(Float, nullable=True)

    # Portfolio state at rejection time
    portfolio_value = Column(Float, nullable=True)
    cash_available = Column(Float, nullable=True)
    current_exposure_pct = Column(Float, nullable=True)
    position_count = Column(Integer, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<OrderRejection(symbol={self.symbol}, reason={self.rejection_reason.value}, time={self.timestamp})>"


class TrailingStopAction(enum.Enum):
    """Types of trailing stop actions"""
    PLACED = "placed"
    TIGHTENED = "tightened"
    TRIGGERED = "triggered"
    CANCELLED = "cancelled"
    MODIFIED = "modified"


class TrailingStopHistory(Base):
    """
    Tracks trailing stop adjustments for positions.
    Provides audit trail of risk management actions.
    """
    __tablename__ = "trailing_stop_history"

    id = Column(Integer, primary_key=True, autoincrement=True)
    position_id = Column(Integer, ForeignKey("positions.id"), nullable=False, index=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Stop price changes
    old_stop_price = Column(Float, nullable=True)
    new_stop_price = Column(Float, nullable=False)
    current_price = Column(Float, nullable=False)

    # Trail percentage changes
    old_trail_pct = Column(Float, nullable=True)
    new_trail_pct = Column(Float, nullable=True)

    # Action type
    action = Column(SQLEnum(TrailingStopAction), nullable=False)
    trigger_reason = Column(Text, nullable=True)

    # Alpaca order tracking
    alpaca_order_id = Column(String(100), nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    # Relationship
    position = relationship("Position", backref="trailing_stop_history")

    def __repr__(self) -> str:
        return f"<TrailingStopHistory(symbol={self.symbol}, action={self.action.value}, stop={self.new_stop_price})>"


class RiskCheckType(enum.Enum):
    """Types of risk checks"""
    POSITION_OPEN = "position_open"
    POSITION_SIZE = "position_size"
    EXPOSURE_CHECK = "exposure_check"
    DAILY_LOSS_CHECK = "daily_loss_check"
    CONCENTRATION_CHECK = "concentration_check"
    STOP_LOSS_CHECK = "stop_loss_check"


class RiskCheckResult(enum.Enum):
    """Results of risk checks"""
    PASSED = "passed"
    FAILED = "failed"
    WARNING = "warning"


class RiskCheckLog(Base):
    """
    Logs risk manager decisions and checks.
    Tracks every risk evaluation for audit and analysis.
    """
    __tablename__ = "risk_check_logs"

    id = Column(Integer, primary_key=True, autoincrement=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)
    symbol = Column(String(20), nullable=True, index=True)

    # Check details
    check_type = Column(SQLEnum(RiskCheckType), nullable=False, index=True)
    result = Column(SQLEnum(RiskCheckResult), nullable=False, index=True)
    reason = Column(Text, nullable=True)

    # Portfolio state at check time
    portfolio_value = Column(Float, nullable=True)
    cash = Column(Float, nullable=True)
    current_exposure_pct = Column(Float, nullable=True)
    position_count = Column(Integer, nullable=True)

    # Request details (for position-related checks)
    requested_quantity = Column(Float, nullable=True)
    requested_price = Column(Float, nullable=True)
    requested_value = Column(Float, nullable=True)

    # Thresholds at check time
    max_exposure_pct = Column(Float, nullable=True)
    max_position_size_pct = Column(Float, nullable=True)
    daily_loss_limit_pct = Column(Float, nullable=True)

    # Strategy context
    strategy = Column(String(50), nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<RiskCheckLog(type={self.check_type.value}, result={self.result.value}, symbol={self.symbol})>"


class GridOrderType(enum.Enum):
    """Grid order types"""
    BUY = "buy"
    SELL = "sell"


class GridOrderStatus(enum.Enum):
    """Grid order status"""
    PENDING = "pending"
    PLACED = "placed"
    FILLED = "filled"
    CANCELLED = "cancelled"
    FAILED = "failed"


class GridOrderExecution(Base):
    """
    Tracks grid trading order executions.
    Replaces JSON file persistence with database storage.
    """
    __tablename__ = "grid_order_executions"

    id = Column(Integer, primary_key=True, autoincrement=True)
    symbol = Column(String(20), nullable=False, index=True)
    timestamp = Column(DateTime, nullable=False, default=datetime.utcnow, index=True)

    # Grid configuration
    grid_level = Column(Integer, nullable=False)
    grid_spacing_pct = Column(Float, nullable=True)
    grid_quantity = Column(Float, nullable=True)

    # Order details
    order_type = Column(SQLEnum(GridOrderType), nullable=False)
    order_status = Column(SQLEnum(GridOrderStatus), nullable=False, index=True)
    limit_price = Column(Float, nullable=False)
    quantity = Column(Float, nullable=False)

    # Execution details
    filled_price = Column(Float, nullable=True)
    filled_quantity = Column(Float, nullable=True)
    filled_at = Column(DateTime, nullable=True)

    # Profit tracking
    realized_profit = Column(Float, nullable=True)
    cumulative_profit = Column(Float, nullable=True)

    # Alpaca integration
    alpaca_order_id = Column(String(100), nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def __repr__(self) -> str:
        return f"<GridOrderExecution(symbol={self.symbol}, level={self.grid_level}, type={self.order_type.value}, status={self.order_status.value})>"


class StrategyPerformance(Base):
    """
    Daily per-strategy performance metrics.
    Aggregates performance data for strategy comparison.
    """
    __tablename__ = "strategy_performance"

    id = Column(Integer, primary_key=True, autoincrement=True)
    strategy = Column(String(50), nullable=False, index=True)
    date = Column(DateTime, nullable=False, index=True)

    # Trade counts
    total_trades = Column(Integer, default=0)
    win_count = Column(Integer, default=0)
    loss_count = Column(Integer, default=0)

    # Derived metrics
    win_rate = Column(Float, nullable=True)

    # P&L
    realized_pnl = Column(Float, default=0.0)
    unrealized_pnl = Column(Float, default=0.0)
    total_pnl = Column(Float, default=0.0)

    # Signal metrics
    signals_generated = Column(Integer, default=0)
    signals_executed = Column(Integer, default=0)
    signals_rejected = Column(Integer, default=0)
    execution_rate = Column(Float, nullable=True)

    # Risk metrics
    avg_position_size = Column(Float, nullable=True)
    max_drawdown_pct = Column(Float, nullable=True)
    sharpe_ratio = Column(Float, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Unique constraint on strategy + date
    __table_args__ = (
        # Ensures one record per strategy per day
        # Index("ix_strategy_date", "strategy", "date", unique=True),
    )

    def __repr__(self) -> str:
        return f"<StrategyPerformance(strategy={self.strategy}, date={self.date}, win_rate={self.win_rate}, pnl={self.total_pnl})>"
